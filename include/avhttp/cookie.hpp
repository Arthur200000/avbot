//
// cookie.hpp
// ~~~~~~~~~~
//
// Copyright (c) 2013 Jack (jack dot wgm at gmail dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// path LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#ifndef __COOKIE_HPP__
#define __COOKIE_HPP__

#if defined(_MSC_VER) && (_MSC_VER >= 1200)
# pragma once
#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)

#include <stdlib.h>     // for atol.
#include <string>
#include <map>
#include <vector>
#include <boost/date_time.hpp>
#include <boost/algorithm/string.hpp>

#include "avhttp/detail/escape_string.hpp"
#include "avhttp/detail/parsers.hpp"
#include "avhttp/file.hpp"

namespace avhttp {

// 用于管理cookie的实现.

class cookies
{
public:
	// cookie结构定义.
	typedef struct cookie_t
	{
		cookie_t()
			: httponly(false)
			, secure(false)
		{}

		// name和value, name必须不为空串.
		std::string name;
		std::string value;

		// 如果为空串, 即匹配任何域名.
		std::string domain;

		// 如果为空串, 即匹配任何路径.
		std::string path;

		// 如果为无效时间, 表示为不过期.
		boost::posix_time::ptime expires;

		// httponly在这里没有意义, secure只有为https时, 才带上此cookie.
		bool httponly;
		bool secure;
	} http_cookie;

public:

	/// Constructor.
	explicit cookies()
	{}

	/// Destructor.
	~cookies()
	{}

	// cookies迭代器实现, 用于访问cookies中的http_cookie.
	struct iterator
	{
		iterator(std::map<std::string, http_cookie>::iterator& iter)
			: m_iter(iter)
		{}

		friend class cookies;

		typedef http_cookie value_type;
		typedef ptrdiff_t difference_type;
		typedef http_cookie const* pointer;
		typedef http_cookie& reference;
		typedef std::forward_iterator_tag iterator_category;

		http_cookie& operator*() { return m_iter->second; }
		http_cookie* operator->() { return &(m_iter->second); }
		iterator& operator++() { m_iter++; return *this; }
		iterator operator++(int)
		{ iterator ret(*this); m_iter++; return ret; }
		iterator& operator--() { m_iter--; return *this; }
		iterator operator--(int)
		{ iterator ret(*this); m_iter--; return ret; }

		bool operator==(iterator const& rhs) const
		{ return m_iter == rhs.m_iter; }

		bool operator!=(iterator const& rhs) const
		{ return m_iter != rhs.m_iter; }

	private:
		std::map<std::string, http_cookie>::iterator m_iter;
	};

	iterator begin() { return iterator(m_cookies.begin()); }
	iterator end() { return iterator(m_cookies.end()); }

	// 保存cookies到指定的文件, 以Netscape HTTP Cookie File格式保存, 兼容curl.
	// @param filename指定保存的文件名.
	// @param default_domain默认的domain, 如果http服务器没有返回domain, 保存时
	//   将以default_domain作为domain来处理, default_domain一般可以指定为所访问
	//   的http服务器domain.
	// 备注: 失败将抛出一个boost::system::system_error异常.
	void save_to_file(const std::string& filename, const std::string& default_domain = "") const
	{
		file f;
		f.open(filename);

		// 写入memo信息.
		if (fs::file_size(filename) == 0)
		{
			std::string memo =
				"# Netscape HTTP Cookie File\n"
				"# http://curl.haxx.se/docs/http-cookies.html\n"
				"# This file was generated by libcurl! Edit at your own risk.\n\n";
			f.write(memo.c_str(), memo.size());
		}

		std::map<std::string, http_cookie>::const_iterator i = m_cookies.begin();
		for (; i != m_cookies.end(); i++)
		{
			const http_cookie& cookie = i->second;
			std::string tmp;

			// domain.
			if (cookie.domain.empty())
			{
				tmp = default_domain;
			}
			else
			{
				tmp = cookie.domain;
			}
			f.write(tmp.c_str(), tmp.size());
			f.write("\t", 1);

			// flag.
			cookie.domain.empty() ? tmp = "FALSE" : tmp = "TRUE";
			f.write(tmp.c_str(), tmp.size());
			f.write("\t", 1);

			// path.
			f.write(cookie.path.c_str(), cookie.path.size());
			f.write("\t", 1);

			// secure.
			cookie.secure ? tmp = "TRUE" : tmp = "FALSE";
			f.write(tmp.c_str(), tmp.size());
			f.write("\t", 1);

			// expires.
			time_t t = 0;
			if (cookie.expires != boost::posix_time::not_a_date_time)
			{
				t = detail::ptime_to_time_t(cookie.expires);
			}
			std::ostringstream oss;
			oss.imbue(std::locale("C"));
			oss << t;
			tmp = oss.str();
			f.write(tmp.c_str(), tmp.size());
			f.write("\t", 1);

			// name.
			f.write(cookie.name.c_str(), cookie.name.size());
			f.write("\t", 1);

			// value.
			f.write(cookie.value.c_str(), cookie.value.size());
			f.write("\t\n", 1);
		}
	}

	// 从文件加载cookie.
	// @param filename指定的文件名, 该文件必须是Netscape HTTP Cookie File格式保存.
	// 备注: 失败将抛出一个boost::system::system_error异常.
	void load_from_file(const std::string& filename)
	{
		file f;
		f.open(filename);

		std::string line;
		while (!f.eof())
		{
			f.getline(line);
			// 过滤掉空行和注释行.
			boost::trim(line);
			if (line.empty() || line.at(0) == '#')
			{
				continue;
			}

			// 开始解析
			std::vector<std::string> split_vec;
			boost::split(split_vec, line, boost::is_any_of("\t"), boost::token_compress_on);
			time_t time;
			time = atol(split_vec[4].c_str());
			http_cookie cookie;
			cookie.domain = split_vec[0];
			cookie.path = split_vec[2];
			cookie.secure = split_vec[3] == "TRUE" ? true : false;
			cookie.expires = boost::posix_time::from_time_t(time);
			std::string s = boost::posix_time::to_simple_string(cookie.expires);
			cookie.name = split_vec[5];
			cookie.value = split_vec[6];

			// 更新或插入cookie.
			m_cookies[cookie.name] = cookie;
		}
	}

	// 更新一个cookie.
	// @name 指定cookie的名称.
	// @value cookie的值.
	cookies& operator()(const std::string& name, const std::string& value)
	{
		http_cookie tmp;
		tmp.name = name;
		tmp.value = value;
		m_cookies.insert(std::make_pair(name, tmp));
		return *this;
	}

	// 更新cookie, 接受一个http服务器返回的Set-Cookie格式字符串的cookie.
	cookies& operator()(const std::string& str)
	{
		std::vector<http_cookie> cookie;
		if (parse_cookie_string(str, cookie))
		{
			for (std::vector<http_cookie>::iterator i = cookie.begin();
				i != cookie.end(); i++)
			{
				// 过期的cookie, 删除之.
				if (i->expires < boost::posix_time::second_clock::local_time())
				{
					std::map<std::string, http_cookie>::iterator finder = m_cookies.find(i->name);
					if (finder != m_cookies.end())
					{
						m_cookies.erase(finder);
					}
				}
				else
				{
					m_cookies[i->name] = *i;	// 更新或插入cookie.
				}
			}
		}

		return *this;
	}

	// 删除指定名称的cookie.
	void remove_cookie(const std::string& name)
	{
		m_cookies.erase(name);
	}

	// 清除所有cookie.
	void clear()
	{
		m_cookies.clear();
	}

	// 返回cookie数.
	int size() const
	{
		return m_cookies.size();
	}

private:

	// 解析cookie字符.
	// 示例字符串:
	// gsid=none; expires=Sun, 22-Sep-2013 14:27:43 GMT; path=/; domain=.fidelity.cn; httponly
	// gsid=none; gsid2=none; expires=Sun, 22-Sep-2013 14:27:43 GMT; path=/; domain=.fidelity.cn
	bool parse_cookie_string(const std::string& str, std::vector<http_cookie>& cookie)
	{
		// 解析状态.
		enum
		{
			cookie_name_start,
			cookie_name,
			cookie_value_start,
			cookie_value,
			cookie_bad
		} state = cookie_name_start;

		std::string::const_iterator iter = str.begin();
		std::string name;
		std::string value;
		std::map<std::string, std::string> tmp;
		http_cookie cookie_tmp;

		// 开始解析http-cookie字符串.
		while (iter != str.end() && state != cookie_bad)
		{
			const char c = *iter++;
			switch (state)
			{
			case cookie_name_start:
				if (c == ' ')
					continue;
				if (detail::is_char(c))
				{
					name.push_back(c);
					state = cookie_name;
				}
				else
					state = cookie_bad;
				break;
			case cookie_name:
				if (c == ';')
				{
					state = cookie_name_start;
					if (name == "secure")
						cookie_tmp.secure = true;
					else if (name == "httponly")
						cookie_tmp.httponly = true;
					else
						state = cookie_bad;
					name = "";
				}
				else if (c == '=')
				{
					value = "";
					state = cookie_value_start;
				}
				else if (detail::is_tspecial(c) || c == ':')
				{
					name = "";
					state = cookie_name_start;
				}
				else if (detail::is_char(c) || c == '_')
					name.push_back(c);
				break;
			case cookie_value_start:
				if (c == ';' || c == '\"' || c == '\'')
					continue;
				if (detail::is_char(c))
				{
					value.push_back(c);
					state = cookie_value;
				}
				else
					state = cookie_bad;
				break;
			case cookie_value:
				if (c == ';' || c == '\"' || c == '\'')
				{
					tmp[name] = value;	// 添加或更新.
					name = "";
					value = "";
					state = cookie_name_start;
				}
				else if (detail::is_char(c))
					value.push_back(c);
				else
					state = cookie_bad;
				break;
			case cookie_bad:
				break;
			}
		}
		if (state == cookie_name && !name.empty())
		{
			if (name == "secure")
				cookie_tmp.secure = true;
			else if (name == "httponly")
				cookie_tmp.httponly = true;
		}
		else if (state == cookie_value && !value.empty())
		{
			tmp[name] = value;	// 添加或更新.
		}
		else if (state == cookie_bad)
		{
			return false;
		}

		for (std::map<std::string, std::string>::iterator i = tmp.begin();
			i != tmp.end(); )
		{
			if (i->first == "expires")
			{
				if (!detail::parse_http_date(i->second, cookie_tmp.expires))
					BOOST_ASSERT(0);	// for debug.
				tmp.erase(i++);
			}
			else if (i->first == "domain")
			{
				cookie_tmp.domain = i->second;
				tmp.erase(i++);
			}
			else if (i->first == "path")
			{
				cookie_tmp.path = i->second;
				tmp.erase(i++);
			}
			else
			{
				i++;
			}
		}

		// 添加到容器返回.
		for (std::map<std::string, std::string>::iterator i = tmp.begin();
			i != tmp.end(); i++)
		{
			cookie_tmp.name = i->first;
			cookie_tmp.value = i->second;
			cookie.push_back(cookie_tmp);
		}

		return true;
	}

private:
	// 保存所有cookie.
	std::map<std::string, http_cookie> m_cookies;
};

} // namespace avhttp

#endif // __COOKIE_HPP__
